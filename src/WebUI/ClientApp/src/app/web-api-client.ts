//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.0.0 (NJsonSchema v10.7.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAgreementsClient {
    getAgreementsByProject(id: number): Observable<AgreementDTO[]>;
    create(command: CreateAgreementCommand): Observable<number>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class AgreementsClient implements IAgreementsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAgreementsByProject(id: number): Observable<AgreementDTO[]> {
        let url_ = this.baseUrl + "/api/Agreements/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAgreementsByProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAgreementsByProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementDTO[]>;
        }));
    }

    protected processGetAgreementsByProject(response: HttpResponseBase): Observable<AgreementDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AgreementDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateAgreementCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Agreements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Agreements/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IChannelsClient {
    getChannels(): Observable<ChannelDTO[]>;
    create(command: CreateChannelCommand): Observable<number>;
    getChannelsByProject(id: number): Observable<ChannelDTO[]>;
    createProjectChannelLink(command: CreateProjectChannelCommand): Observable<number>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ChannelsClient implements IChannelsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getChannels(): Observable<ChannelDTO[]> {
        let url_ = this.baseUrl + "/api/Channels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChannels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChannels(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChannelDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChannelDTO[]>;
        }));
    }

    protected processGetChannels(response: HttpResponseBase): Observable<ChannelDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChannelDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateChannelCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Channels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getChannelsByProject(id: number): Observable<ChannelDTO[]> {
        let url_ = this.baseUrl + "/api/Channels/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChannelsByProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChannelsByProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChannelDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChannelDTO[]>;
        }));
    }

    protected processGetChannelsByProject(response: HttpResponseBase): Observable<ChannelDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChannelDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createProjectChannelLink(command: CreateProjectChannelCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Channels/projectChannel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProjectChannelLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProjectChannelLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateProjectChannelLink(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Channels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IContactsClient {
    getContacts(): Observable<ContactDTO[]>;
    create(command: CreateContactCommand): Observable<number>;
    getContact(id: number): Observable<ContactDTO>;
    delete(id: number): Observable<FileResponse>;
    getContactsByProject(id: number): Observable<ContactDTO[]>;
    getContactsByType(type: ContactType): Observable<ContactDTO[]>;
    createProjectContactLink(command: CreateProjectContactCommand): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class ContactsClient implements IContactsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getContacts(): Observable<ContactDTO[]> {
        let url_ = this.baseUrl + "/api/Contacts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactDTO[]>;
        }));
    }

    protected processGetContacts(response: HttpResponseBase): Observable<ContactDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateContactCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Contacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getContact(id: number): Observable<ContactDTO> {
        let url_ = this.baseUrl + "/api/Contacts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactDTO>;
        }));
    }

    protected processGetContact(response: HttpResponseBase): Observable<ContactDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Contacts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getContactsByProject(id: number): Observable<ContactDTO[]> {
        let url_ = this.baseUrl + "/api/Contacts/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactsByProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactsByProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactDTO[]>;
        }));
    }

    protected processGetContactsByProject(response: HttpResponseBase): Observable<ContactDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getContactsByType(type: ContactType): Observable<ContactDTO[]> {
        let url_ = this.baseUrl + "/api/Contacts/type/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactsByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactsByType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactDTO[]>;
        }));
    }

    protected processGetContactsByType(response: HttpResponseBase): Observable<ContactDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createProjectContactLink(command: CreateProjectContactCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Contacts/projectContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProjectContactLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProjectContactLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateProjectContactLink(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICountriesClient {
    getCountries(): Observable<CountryDTO[]>;
    create(command: CreateCountryCommand): Observable<number>;
    getCountry(id: number): Observable<CountryDTO>;
    delete(id: number): Observable<FileResponse>;
    getCountriesByProject(id: number): Observable<CountryDTO[]>;
    createProjectCountryLink(command: CreateProjectCountryCommand): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class CountriesClient implements ICountriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCountries(): Observable<CountryDTO[]> {
        let url_ = this.baseUrl + "/api/Countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDTO[]>;
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<CountryDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCountryCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Countries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCountry(id: number): Observable<CountryDTO> {
        let url_ = this.baseUrl + "/api/Countries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDTO>;
        }));
    }

    protected processGetCountry(response: HttpResponseBase): Observable<CountryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Countries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCountriesByProject(id: number): Observable<CountryDTO[]> {
        let url_ = this.baseUrl + "/api/Countries/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountriesByProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountriesByProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDTO[]>;
        }));
    }

    protected processGetCountriesByProject(response: HttpResponseBase): Observable<CountryDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createProjectCountryLink(command: CreateProjectCountryCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Countries/projectCountry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProjectCountryLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProjectCountryLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateProjectCountryLink(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICustomersClient {
    getCustomers(): Observable<CustomerDTO[]>;
    create(command: CreateCustomerCommand): Observable<number>;
    getCustomersBy(sectorId: number): Observable<CustomerDTO[]>;
    getCustomer(id: number): Observable<CustomerDTO>;
    update(id: number, command: UpdateCustomerCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CustomersClient implements ICustomersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCustomers(): Observable<CustomerDTO[]> {
        let url_ = this.baseUrl + "/api/Customers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDTO[]>;
        }));
    }

    protected processGetCustomers(response: HttpResponseBase): Observable<CustomerDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCustomerCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Customers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCustomersBy(sectorId: number): Observable<CustomerDTO[]> {
        let url_ = this.baseUrl + "/api/Customers/sector/{sectorId}";
        if (sectorId === undefined || sectorId === null)
            throw new Error("The parameter 'sectorId' must be defined.");
        url_ = url_.replace("{sectorId}", encodeURIComponent("" + sectorId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomersBy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomersBy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDTO[]>;
        }));
    }

    protected processGetCustomersBy(response: HttpResponseBase): Observable<CustomerDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCustomer(id: number): Observable<CustomerDTO> {
        let url_ = this.baseUrl + "/api/Customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDTO>;
        }));
    }

    protected processGetCustomer(response: HttpResponseBase): Observable<CustomerDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateCustomerCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProjectsClient {
    getProjects(pageNumber: number, pageSize: number | undefined, searchText: string | null | undefined, verticalId: string | null | undefined, sectorId: string | null | undefined, customerId: string | null | undefined, technologyId: string | null | undefined, countryId: string | null | undefined, offerId: string | null | undefined, targetId: string | null | undefined, isPrivate: boolean | undefined, isPublic: boolean | undefined): Observable<PaginatedListOfProjectDTO>;
    getProject(id: number): Observable<ProjectDTO>;
    update(id: number, command: UpdateProjectCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    downloadPPTXFile(projectId: number): Observable<FileResponse>;
    create(command: CreateProjectCommand): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class ProjectsClient implements IProjectsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getProjects(pageNumber: number, pageSize: number | undefined, searchText: string | null | undefined, verticalId: string | null | undefined, sectorId: string | null | undefined, customerId: string | null | undefined, technologyId: string | null | undefined, countryId: string | null | undefined, offerId: string | null | undefined, targetId: string | null | undefined, isPrivate: boolean | undefined, isPublic: boolean | undefined): Observable<PaginatedListOfProjectDTO> {
        let url_ = this.baseUrl + "/api/Projects/page/{pageNumber}?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (verticalId !== undefined && verticalId !== null)
            url_ += "verticalId=" + encodeURIComponent("" + verticalId) + "&";
        if (sectorId !== undefined && sectorId !== null)
            url_ += "sectorId=" + encodeURIComponent("" + sectorId) + "&";
        if (customerId !== undefined && customerId !== null)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        if (technologyId !== undefined && technologyId !== null)
            url_ += "technologyId=" + encodeURIComponent("" + technologyId) + "&";
        if (countryId !== undefined && countryId !== null)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        if (offerId !== undefined && offerId !== null)
            url_ += "offerId=" + encodeURIComponent("" + offerId) + "&";
        if (targetId !== undefined && targetId !== null)
            url_ += "targetId=" + encodeURIComponent("" + targetId) + "&";
        if (isPrivate === null)
            throw new Error("The parameter 'isPrivate' cannot be null.");
        else if (isPrivate !== undefined)
            url_ += "isPrivate=" + encodeURIComponent("" + isPrivate) + "&";
        if (isPublic === null)
            throw new Error("The parameter 'isPublic' cannot be null.");
        else if (isPublic !== undefined)
            url_ += "isPublic=" + encodeURIComponent("" + isPublic) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProjectDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProjectDTO>;
        }));
    }

    protected processGetProjects(response: HttpResponseBase): Observable<PaginatedListOfProjectDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProjectDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProject(id: number): Observable<ProjectDTO> {
        let url_ = this.baseUrl + "/api/Projects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectDTO>;
        }));
    }

    protected processGetProject(response: HttpResponseBase): Observable<ProjectDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateProjectCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Projects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Projects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    downloadPPTXFile(projectId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Projects/download/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadPPTXFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadPPTXFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadPPTXFile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProjectCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Projects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISectorsClient {
    getSectors(): Observable<SectorDTO[]>;
    create(command: CreateSectorCommand): Observable<number>;
    getSectorsByVertical(id: number): Observable<SectorDTO[]>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class SectorsClient implements ISectorsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getSectors(): Observable<SectorDTO[]> {
        let url_ = this.baseUrl + "/api/Sectors";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSectors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSectors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SectorDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SectorDTO[]>;
        }));
    }

    protected processGetSectors(response: HttpResponseBase): Observable<SectorDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SectorDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateSectorCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Sectors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSectorsByVertical(id: number): Observable<SectorDTO[]> {
        let url_ = this.baseUrl + "/api/Sectors/vertical/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSectorsByVertical(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSectorsByVertical(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SectorDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SectorDTO[]>;
        }));
    }

    protected processGetSectorsByVertical(response: HttpResponseBase): Observable<SectorDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SectorDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Sectors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITagsClient {
    getTags(): Observable<TagDTO[]>;
    create(command: CreateTagCommand): Observable<number>;
    getTagsByProject(id: number): Observable<TagDTO[]>;
    createProjectTagLink(command: CreateProjectTagCommand): Observable<number>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TagsClient implements ITagsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTags(): Observable<TagDTO[]> {
        let url_ = this.baseUrl + "/api/Tags";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTags(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TagDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TagDTO[]>;
        }));
    }

    protected processGetTags(response: HttpResponseBase): Observable<TagDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TagDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateTagCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTagsByProject(id: number): Observable<TagDTO[]> {
        let url_ = this.baseUrl + "/api/Tags/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTagsByProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagsByProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TagDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TagDTO[]>;
        }));
    }

    protected processGetTagsByProject(response: HttpResponseBase): Observable<TagDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TagDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createProjectTagLink(command: CreateProjectTagCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Tags/projectTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProjectTagLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProjectTagLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateProjectTagLink(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Tags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITargetsWorkClient {
    getTargetsWorkDTO(): Observable<TargetWorkDTO[]>;
    create(command: CreateTargetWorkCommand): Observable<number>;
    getTargetsWorkByProject(id: number): Observable<TargetWorkDTO[]>;
    createProjectTargetWorkDTOLink(command: CreateProjectTargetWorkCommand): Observable<number>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TargetsWorkClient implements ITargetsWorkClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTargetsWorkDTO(): Observable<TargetWorkDTO[]> {
        let url_ = this.baseUrl + "/api/TargetsWork";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTargetsWorkDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTargetsWorkDTO(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TargetWorkDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TargetWorkDTO[]>;
        }));
    }

    protected processGetTargetsWorkDTO(response: HttpResponseBase): Observable<TargetWorkDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TargetWorkDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateTargetWorkCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TargetsWork";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTargetsWorkByProject(id: number): Observable<TargetWorkDTO[]> {
        let url_ = this.baseUrl + "/api/TargetsWork/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTargetsWorkByProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTargetsWorkByProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TargetWorkDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TargetWorkDTO[]>;
        }));
    }

    protected processGetTargetsWorkByProject(response: HttpResponseBase): Observable<TargetWorkDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TargetWorkDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createProjectTargetWorkDTOLink(command: CreateProjectTargetWorkCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TargetsWork/projectTargetWork";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProjectTargetWorkDTOLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProjectTargetWorkDTOLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateProjectTargetWorkDTOLink(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TargetsWork/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITechnologiesClient {
    getTechnologies(): Observable<TechnologyDTO[]>;
    create(command: CreateTechnologyCommand): Observable<number>;
    getTechnology(id: number): Observable<TechnologyDTO>;
    delete(id: number): Observable<FileResponse>;
    getTechnologiesByProject(id: number): Observable<TechnologyDTO[]>;
    createProjectTechnologyLink(command: CreateProjectTechnologyCommand): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class TechnologiesClient implements ITechnologiesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTechnologies(): Observable<TechnologyDTO[]> {
        let url_ = this.baseUrl + "/api/Technologies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTechnologies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTechnologies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TechnologyDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TechnologyDTO[]>;
        }));
    }

    protected processGetTechnologies(response: HttpResponseBase): Observable<TechnologyDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TechnologyDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateTechnologyCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Technologies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTechnology(id: number): Observable<TechnologyDTO> {
        let url_ = this.baseUrl + "/api/Technologies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTechnology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTechnology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TechnologyDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TechnologyDTO>;
        }));
    }

    protected processGetTechnology(response: HttpResponseBase): Observable<TechnologyDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TechnologyDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Technologies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTechnologiesByProject(id: number): Observable<TechnologyDTO[]> {
        let url_ = this.baseUrl + "/api/Technologies/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTechnologiesByProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTechnologiesByProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TechnologyDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TechnologyDTO[]>;
        }));
    }

    protected processGetTechnologiesByProject(response: HttpResponseBase): Observable<TechnologyDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TechnologyDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createProjectTechnologyLink(command: CreateProjectTechnologyCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Technologies/projectTechnology";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProjectTechnologyLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProjectTechnologyLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateProjectTechnologyLink(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITribeOffersClient {
    getTribeOffers(): Observable<TribeOfferDTO[]>;
    create(command: CreateTribeOfferCommand): Observable<number>;
    getTribeOffersByProject(id: number): Observable<TribeOfferDTO[]>;
    createProjectTribeOfferLink(command: CreateProjectTribeOfferCommand): Observable<number>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TribeOffersClient implements ITribeOffersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTribeOffers(): Observable<TribeOfferDTO[]> {
        let url_ = this.baseUrl + "/api/TribeOffers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTribeOffers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTribeOffers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TribeOfferDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TribeOfferDTO[]>;
        }));
    }

    protected processGetTribeOffers(response: HttpResponseBase): Observable<TribeOfferDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TribeOfferDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateTribeOfferCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TribeOffers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTribeOffersByProject(id: number): Observable<TribeOfferDTO[]> {
        let url_ = this.baseUrl + "/api/TribeOffers/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTribeOffersByProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTribeOffersByProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TribeOfferDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TribeOfferDTO[]>;
        }));
    }

    protected processGetTribeOffersByProject(response: HttpResponseBase): Observable<TribeOfferDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TribeOfferDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createProjectTribeOfferLink(command: CreateProjectTribeOfferCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TribeOffers/projectTribeOffer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProjectTribeOfferLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProjectTribeOfferLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateProjectTribeOfferLink(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TribeOffers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVerticalsClient {
    getVerticals(): Observable<VerticalDTO[]>;
    create(command: CreateVerticalCommand): Observable<number>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class VerticalsClient implements IVerticalsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getVerticals(): Observable<VerticalDTO[]> {
        let url_ = this.baseUrl + "/api/Verticals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVerticals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVerticals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerticalDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerticalDTO[]>;
        }));
    }

    protected processGetVerticals(response: HttpResponseBase): Observable<VerticalDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerticalDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateVerticalCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Verticals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Verticals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AgreementDTO implements IAgreementDTO {
    id?: number;
    name?: string;
    path?: string;
    projectId?: number;
    project?: Project | undefined;

    constructor(data?: IAgreementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.path = _data["path"];
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AgreementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["path"] = this.path;
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAgreementDTO {
    id?: number;
    name?: string;
    path?: string;
    projectId?: number;
    project?: Project | undefined;
}

export abstract class BaseEntity implements IBaseEntity {
    id?: number;
    domainEvents?: BaseEvent[];

    constructor(data?: IBaseEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                this.domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    this.domainEvents!.push(BaseEvent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaseEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBaseEntity {
    id?: number;
    domainEvents?: BaseEvent[];
}

export abstract class BaseAuditableEntity extends BaseEntity implements IBaseAuditableEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;

    constructor(data?: IBaseAuditableEntity) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static override fromJS(data: any): BaseAuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseAuditableEntity' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        super.toJSON(data);
        return data;
    }
}

export interface IBaseAuditableEntity extends IBaseEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;
}

export class Project extends BaseAuditableEntity implements IProject {
    name?: string;
    endYear?: number;
    isFinished?: boolean;
    price?: number;
    manDay?: number;
    solutions?: string | undefined;
    issues?: string | undefined;
    benefits?: string | undefined;
    narative?: string | undefined;
    isPublic?: boolean;
    photoUrl?: string | undefined;
    dataQualityPercent?: number;
    customerId?: number;
    customer?: Customer | undefined;
    projectTribeOffers?: ProjectTribeOffers[];
    projectTags?: ProjectTags[];
    projectCountries?: ProjectCountries[];
    projectTargetsWork?: ProjectTargetsWork[];
    projectContacts?: ProjectContacts[];
    agreements?: Agreement[];
    projectTechnologies?: ProjectTechnologies[];
    projectChannels?: ProjectChannels[];

    constructor(data?: IProject) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.endYear = _data["endYear"];
            this.isFinished = _data["isFinished"];
            this.price = _data["price"];
            this.manDay = _data["manDay"];
            this.solutions = _data["solutions"];
            this.issues = _data["issues"];
            this.benefits = _data["benefits"];
            this.narative = _data["narative"];
            this.isPublic = _data["isPublic"];
            this.photoUrl = _data["photoUrl"];
            this.dataQualityPercent = _data["dataQualityPercent"];
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            if (Array.isArray(_data["projectTribeOffers"])) {
                this.projectTribeOffers = [] as any;
                for (let item of _data["projectTribeOffers"])
                    this.projectTribeOffers!.push(ProjectTribeOffers.fromJS(item));
            }
            if (Array.isArray(_data["projectTags"])) {
                this.projectTags = [] as any;
                for (let item of _data["projectTags"])
                    this.projectTags!.push(ProjectTags.fromJS(item));
            }
            if (Array.isArray(_data["projectCountries"])) {
                this.projectCountries = [] as any;
                for (let item of _data["projectCountries"])
                    this.projectCountries!.push(ProjectCountries.fromJS(item));
            }
            if (Array.isArray(_data["projectTargetsWork"])) {
                this.projectTargetsWork = [] as any;
                for (let item of _data["projectTargetsWork"])
                    this.projectTargetsWork!.push(ProjectTargetsWork.fromJS(item));
            }
            if (Array.isArray(_data["projectContacts"])) {
                this.projectContacts = [] as any;
                for (let item of _data["projectContacts"])
                    this.projectContacts!.push(ProjectContacts.fromJS(item));
            }
            if (Array.isArray(_data["agreements"])) {
                this.agreements = [] as any;
                for (let item of _data["agreements"])
                    this.agreements!.push(Agreement.fromJS(item));
            }
            if (Array.isArray(_data["projectTechnologies"])) {
                this.projectTechnologies = [] as any;
                for (let item of _data["projectTechnologies"])
                    this.projectTechnologies!.push(ProjectTechnologies.fromJS(item));
            }
            if (Array.isArray(_data["projectChannels"])) {
                this.projectChannels = [] as any;
                for (let item of _data["projectChannels"])
                    this.projectChannels!.push(ProjectChannels.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Project {
        data = typeof data === 'object' ? data : {};
        let result = new Project();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["endYear"] = this.endYear;
        data["isFinished"] = this.isFinished;
        data["price"] = this.price;
        data["manDay"] = this.manDay;
        data["solutions"] = this.solutions;
        data["issues"] = this.issues;
        data["benefits"] = this.benefits;
        data["narative"] = this.narative;
        data["isPublic"] = this.isPublic;
        data["photoUrl"] = this.photoUrl;
        data["dataQualityPercent"] = this.dataQualityPercent;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (Array.isArray(this.projectTribeOffers)) {
            data["projectTribeOffers"] = [];
            for (let item of this.projectTribeOffers)
                data["projectTribeOffers"].push(item.toJSON());
        }
        if (Array.isArray(this.projectTags)) {
            data["projectTags"] = [];
            for (let item of this.projectTags)
                data["projectTags"].push(item.toJSON());
        }
        if (Array.isArray(this.projectCountries)) {
            data["projectCountries"] = [];
            for (let item of this.projectCountries)
                data["projectCountries"].push(item.toJSON());
        }
        if (Array.isArray(this.projectTargetsWork)) {
            data["projectTargetsWork"] = [];
            for (let item of this.projectTargetsWork)
                data["projectTargetsWork"].push(item.toJSON());
        }
        if (Array.isArray(this.projectContacts)) {
            data["projectContacts"] = [];
            for (let item of this.projectContacts)
                data["projectContacts"].push(item.toJSON());
        }
        if (Array.isArray(this.agreements)) {
            data["agreements"] = [];
            for (let item of this.agreements)
                data["agreements"].push(item.toJSON());
        }
        if (Array.isArray(this.projectTechnologies)) {
            data["projectTechnologies"] = [];
            for (let item of this.projectTechnologies)
                data["projectTechnologies"].push(item.toJSON());
        }
        if (Array.isArray(this.projectChannels)) {
            data["projectChannels"] = [];
            for (let item of this.projectChannels)
                data["projectChannels"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IProject extends IBaseAuditableEntity {
    name?: string;
    endYear?: number;
    isFinished?: boolean;
    price?: number;
    manDay?: number;
    solutions?: string | undefined;
    issues?: string | undefined;
    benefits?: string | undefined;
    narative?: string | undefined;
    isPublic?: boolean;
    photoUrl?: string | undefined;
    dataQualityPercent?: number;
    customerId?: number;
    customer?: Customer | undefined;
    projectTribeOffers?: ProjectTribeOffers[];
    projectTags?: ProjectTags[];
    projectCountries?: ProjectCountries[];
    projectTargetsWork?: ProjectTargetsWork[];
    projectContacts?: ProjectContacts[];
    agreements?: Agreement[];
    projectTechnologies?: ProjectTechnologies[];
    projectChannels?: ProjectChannels[];
}

export class Customer extends BaseEntity implements ICustomer {
    name?: string;
    photoUrl?: string | undefined;
    verticalId?: number;
    vertical?: Vertical | undefined;
    sectorId?: number;
    sector?: Sector | undefined;
    projects?: Project[];

    constructor(data?: ICustomer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.photoUrl = _data["photoUrl"];
            this.verticalId = _data["verticalId"];
            this.vertical = _data["vertical"] ? Vertical.fromJS(_data["vertical"]) : <any>undefined;
            this.sectorId = _data["sectorId"];
            this.sector = _data["sector"] ? Sector.fromJS(_data["sector"]) : <any>undefined;
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(Project.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["photoUrl"] = this.photoUrl;
        data["verticalId"] = this.verticalId;
        data["vertical"] = this.vertical ? this.vertical.toJSON() : <any>undefined;
        data["sectorId"] = this.sectorId;
        data["sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICustomer extends IBaseEntity {
    name?: string;
    photoUrl?: string | undefined;
    verticalId?: number;
    vertical?: Vertical | undefined;
    sectorId?: number;
    sector?: Sector | undefined;
    projects?: Project[];
}

export class Vertical extends BaseEntity implements IVertical {
    name?: string;
    sectors?: Sector[];
    customers?: Customer[];

    constructor(data?: IVertical) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["sectors"])) {
                this.sectors = [] as any;
                for (let item of _data["sectors"])
                    this.sectors!.push(Sector.fromJS(item));
            }
            if (Array.isArray(_data["customers"])) {
                this.customers = [] as any;
                for (let item of _data["customers"])
                    this.customers!.push(Customer.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Vertical {
        data = typeof data === 'object' ? data : {};
        let result = new Vertical();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.sectors)) {
            data["sectors"] = [];
            for (let item of this.sectors)
                data["sectors"].push(item.toJSON());
        }
        if (Array.isArray(this.customers)) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IVertical extends IBaseEntity {
    name?: string;
    sectors?: Sector[];
    customers?: Customer[];
}

export class Sector extends BaseEntity implements ISector {
    name?: string;
    verticalId?: number;
    vertical?: Vertical | undefined;
    customers?: Customer[];

    constructor(data?: ISector) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.verticalId = _data["verticalId"];
            this.vertical = _data["vertical"] ? Vertical.fromJS(_data["vertical"]) : <any>undefined;
            if (Array.isArray(_data["customers"])) {
                this.customers = [] as any;
                for (let item of _data["customers"])
                    this.customers!.push(Customer.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Sector {
        data = typeof data === 'object' ? data : {};
        let result = new Sector();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["verticalId"] = this.verticalId;
        data["vertical"] = this.vertical ? this.vertical.toJSON() : <any>undefined;
        if (Array.isArray(this.customers)) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISector extends IBaseEntity {
    name?: string;
    verticalId?: number;
    vertical?: Vertical | undefined;
    customers?: Customer[];
}

export abstract class BaseEvent implements IBaseEvent {

    constructor(data?: IBaseEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BaseEvent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEvent' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IBaseEvent {
}

export class ProjectTribeOffers implements IProjectTribeOffers {
    projectId?: number;
    project?: Project | undefined;
    tribeOfferId?: number;
    tribeOffer?: TribeOffer | undefined;

    constructor(data?: IProjectTribeOffers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            this.tribeOfferId = _data["tribeOfferId"];
            this.tribeOffer = _data["tribeOffer"] ? TribeOffer.fromJS(_data["tribeOffer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectTribeOffers {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTribeOffers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["tribeOfferId"] = this.tribeOfferId;
        data["tribeOffer"] = this.tribeOffer ? this.tribeOffer.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProjectTribeOffers {
    projectId?: number;
    project?: Project | undefined;
    tribeOfferId?: number;
    tribeOffer?: TribeOffer | undefined;
}

export class TribeOffer extends BaseEntity implements ITribeOffer {
    name?: string;
    projectTribeOffers?: ProjectTribeOffers[];

    constructor(data?: ITribeOffer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["projectTribeOffers"])) {
                this.projectTribeOffers = [] as any;
                for (let item of _data["projectTribeOffers"])
                    this.projectTribeOffers!.push(ProjectTribeOffers.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): TribeOffer {
        data = typeof data === 'object' ? data : {};
        let result = new TribeOffer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.projectTribeOffers)) {
            data["projectTribeOffers"] = [];
            for (let item of this.projectTribeOffers)
                data["projectTribeOffers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ITribeOffer extends IBaseEntity {
    name?: string;
    projectTribeOffers?: ProjectTribeOffers[];
}

export class ProjectTags implements IProjectTags {
    projectId?: number;
    project?: Project | undefined;
    tagId?: number;
    tag?: Tag | undefined;

    constructor(data?: IProjectTags) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            this.tagId = _data["tagId"];
            this.tag = _data["tag"] ? Tag.fromJS(_data["tag"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectTags {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTags();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["tagId"] = this.tagId;
        data["tag"] = this.tag ? this.tag.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProjectTags {
    projectId?: number;
    project?: Project | undefined;
    tagId?: number;
    tag?: Tag | undefined;
}

export class Tag extends BaseEntity implements ITag {
    name?: string;
    projectTags?: ProjectTags[];

    constructor(data?: ITag) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["projectTags"])) {
                this.projectTags = [] as any;
                for (let item of _data["projectTags"])
                    this.projectTags!.push(ProjectTags.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Tag {
        data = typeof data === 'object' ? data : {};
        let result = new Tag();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.projectTags)) {
            data["projectTags"] = [];
            for (let item of this.projectTags)
                data["projectTags"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ITag extends IBaseEntity {
    name?: string;
    projectTags?: ProjectTags[];
}

export class ProjectCountries implements IProjectCountries {
    projectId?: number;
    project?: Project | undefined;
    countryId?: number;
    country?: Country | undefined;

    constructor(data?: IProjectCountries) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            this.countryId = _data["countryId"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectCountries {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectCountries();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProjectCountries {
    projectId?: number;
    project?: Project | undefined;
    countryId?: number;
    country?: Country | undefined;
}

export class Country extends BaseEntity implements ICountry {
    name?: string;
    initial?: string;
    projectCountries?: ProjectCountries[];

    constructor(data?: ICountry) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.initial = _data["initial"];
            if (Array.isArray(_data["projectCountries"])) {
                this.projectCountries = [] as any;
                for (let item of _data["projectCountries"])
                    this.projectCountries!.push(ProjectCountries.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["initial"] = this.initial;
        if (Array.isArray(this.projectCountries)) {
            data["projectCountries"] = [];
            for (let item of this.projectCountries)
                data["projectCountries"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICountry extends IBaseEntity {
    name?: string;
    initial?: string;
    projectCountries?: ProjectCountries[];
}

export class ProjectTargetsWork implements IProjectTargetsWork {
    projectId?: number;
    project?: Project | undefined;
    targetWorkId?: number;
    targetWork?: TargetWork | undefined;

    constructor(data?: IProjectTargetsWork) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            this.targetWorkId = _data["targetWorkId"];
            this.targetWork = _data["targetWork"] ? TargetWork.fromJS(_data["targetWork"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectTargetsWork {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTargetsWork();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["targetWorkId"] = this.targetWorkId;
        data["targetWork"] = this.targetWork ? this.targetWork.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProjectTargetsWork {
    projectId?: number;
    project?: Project | undefined;
    targetWorkId?: number;
    targetWork?: TargetWork | undefined;
}

export class TargetWork extends BaseEntity implements ITargetWork {
    name?: string;
    projectTargetsWork?: ProjectTargetsWork[];

    constructor(data?: ITargetWork) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["projectTargetsWork"])) {
                this.projectTargetsWork = [] as any;
                for (let item of _data["projectTargetsWork"])
                    this.projectTargetsWork!.push(ProjectTargetsWork.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): TargetWork {
        data = typeof data === 'object' ? data : {};
        let result = new TargetWork();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.projectTargetsWork)) {
            data["projectTargetsWork"] = [];
            for (let item of this.projectTargetsWork)
                data["projectTargetsWork"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ITargetWork extends IBaseEntity {
    name?: string;
    projectTargetsWork?: ProjectTargetsWork[];
}

export class ProjectContacts implements IProjectContacts {
    projectId?: number;
    project?: Project | undefined;
    contactId?: number;
    contact?: Contact | undefined;
    contactType?: ContactType;

    constructor(data?: IProjectContacts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            this.contactId = _data["contactId"];
            this.contact = _data["contact"] ? Contact.fromJS(_data["contact"]) : <any>undefined;
            this.contactType = _data["contactType"];
        }
    }

    static fromJS(data: any): ProjectContacts {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectContacts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["contactType"] = this.contactType;
        return data;
    }
}

export interface IProjectContacts {
    projectId?: number;
    project?: Project | undefined;
    contactId?: number;
    contact?: Contact | undefined;
    contactType?: ContactType;
}

export class Contact extends BaseEntity implements IContact {
    name?: string;
    projectContacts?: ProjectContacts[];

    constructor(data?: IContact) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["projectContacts"])) {
                this.projectContacts = [] as any;
                for (let item of _data["projectContacts"])
                    this.projectContacts!.push(ProjectContacts.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.projectContacts)) {
            data["projectContacts"] = [];
            for (let item of this.projectContacts)
                data["projectContacts"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IContact extends IBaseEntity {
    name?: string;
    projectContacts?: ProjectContacts[];
}

export enum ContactType {
    SALES = 0,
    DELIVERY = 1,
}

export class Agreement extends BaseEntity implements IAgreement {
    name?: string;
    path?: string;
    projectId?: number;
    project?: Project | undefined;

    constructor(data?: IAgreement) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.path = _data["path"];
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Agreement {
        data = typeof data === 'object' ? data : {};
        let result = new Agreement();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["path"] = this.path;
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAgreement extends IBaseEntity {
    name?: string;
    path?: string;
    projectId?: number;
    project?: Project | undefined;
}

export class ProjectTechnologies implements IProjectTechnologies {
    projectId?: number;
    project?: Project | undefined;
    technologyId?: number;
    technology?: Technology | undefined;

    constructor(data?: IProjectTechnologies) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            this.technologyId = _data["technologyId"];
            this.technology = _data["technology"] ? Technology.fromJS(_data["technology"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectTechnologies {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTechnologies();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["technologyId"] = this.technologyId;
        data["technology"] = this.technology ? this.technology.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProjectTechnologies {
    projectId?: number;
    project?: Project | undefined;
    technologyId?: number;
    technology?: Technology | undefined;
}

export class Technology extends BaseEntity implements ITechnology {
    name?: string;
    projectTechnologies?: ProjectTechnologies[];

    constructor(data?: ITechnology) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["projectTechnologies"])) {
                this.projectTechnologies = [] as any;
                for (let item of _data["projectTechnologies"])
                    this.projectTechnologies!.push(ProjectTechnologies.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Technology {
        data = typeof data === 'object' ? data : {};
        let result = new Technology();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.projectTechnologies)) {
            data["projectTechnologies"] = [];
            for (let item of this.projectTechnologies)
                data["projectTechnologies"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ITechnology extends IBaseEntity {
    name?: string;
    projectTechnologies?: ProjectTechnologies[];
}

export class ProjectChannels implements IProjectChannels {
    projectId?: number;
    project?: Project | undefined;
    channelId?: number;
    channel?: Channel | undefined;

    constructor(data?: IProjectChannels) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            this.channelId = _data["channelId"];
            this.channel = _data["channel"] ? Channel.fromJS(_data["channel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectChannels {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectChannels();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["channelId"] = this.channelId;
        data["channel"] = this.channel ? this.channel.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProjectChannels {
    projectId?: number;
    project?: Project | undefined;
    channelId?: number;
    channel?: Channel | undefined;
}

export class Channel extends BaseEntity implements IChannel {
    name?: string;
    projectChannels?: ProjectChannels[];

    constructor(data?: IChannel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["projectChannels"])) {
                this.projectChannels = [] as any;
                for (let item of _data["projectChannels"])
                    this.projectChannels!.push(ProjectChannels.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Channel {
        data = typeof data === 'object' ? data : {};
        let result = new Channel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.projectChannels)) {
            data["projectChannels"] = [];
            for (let item of this.projectChannels)
                data["projectChannels"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IChannel extends IBaseEntity {
    name?: string;
    projectChannels?: ProjectChannels[];
}

export class CreateAgreementCommand implements ICreateAgreementCommand {
    name?: string | undefined;
    path?: string | undefined;
    projectId?: number;

    constructor(data?: ICreateAgreementCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.path = _data["path"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): CreateAgreementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAgreementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["path"] = this.path;
        data["projectId"] = this.projectId;
        return data;
    }
}

export interface ICreateAgreementCommand {
    name?: string | undefined;
    path?: string | undefined;
    projectId?: number;
}

export class ChannelDTO implements IChannelDTO {
    id?: number;
    name?: string;
    projectChannels?: ProjectChannels[];

    constructor(data?: IChannelDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["projectChannels"])) {
                this.projectChannels = [] as any;
                for (let item of _data["projectChannels"])
                    this.projectChannels!.push(ProjectChannels.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChannelDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.projectChannels)) {
            data["projectChannels"] = [];
            for (let item of this.projectChannels)
                data["projectChannels"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChannelDTO {
    id?: number;
    name?: string;
    projectChannels?: ProjectChannels[];
}

export class CreateProjectChannelCommand implements ICreateProjectChannelCommand {
    projectId?: number;
    channelId?: number;

    constructor(data?: ICreateProjectChannelCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.channelId = _data["channelId"];
        }
    }

    static fromJS(data: any): CreateProjectChannelCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectChannelCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["channelId"] = this.channelId;
        return data;
    }
}

export interface ICreateProjectChannelCommand {
    projectId?: number;
    channelId?: number;
}

export class CreateChannelCommand implements ICreateChannelCommand {
    name?: string | undefined;

    constructor(data?: ICreateChannelCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateChannelCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChannelCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateChannelCommand {
    name?: string | undefined;
}

export class ContactDTO implements IContactDTO {
    id?: number;
    name?: string;
    projectContacts?: ProjectContacts[];

    constructor(data?: IContactDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["projectContacts"])) {
                this.projectContacts = [] as any;
                for (let item of _data["projectContacts"])
                    this.projectContacts!.push(ProjectContacts.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.projectContacts)) {
            data["projectContacts"] = [];
            for (let item of this.projectContacts)
                data["projectContacts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContactDTO {
    id?: number;
    name?: string;
    projectContacts?: ProjectContacts[];
}

export class CreateContactCommand implements ICreateContactCommand {
    name?: string | undefined;

    constructor(data?: ICreateContactCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateContactCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateContactCommand {
    name?: string | undefined;
}

export class CreateProjectContactCommand implements ICreateProjectContactCommand {
    projectId?: number;
    contactId?: number;
    contactType?: ContactType;

    constructor(data?: ICreateProjectContactCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.contactId = _data["contactId"];
            this.contactType = _data["contactType"];
        }
    }

    static fromJS(data: any): CreateProjectContactCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectContactCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["contactId"] = this.contactId;
        data["contactType"] = this.contactType;
        return data;
    }
}

export interface ICreateProjectContactCommand {
    projectId?: number;
    contactId?: number;
    contactType?: ContactType;
}

export class CountryDTO implements ICountryDTO {
    id?: number;
    name?: string;
    initial?: string;
    projectCountries?: ProjectCountries[];

    constructor(data?: ICountryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.initial = _data["initial"];
            if (Array.isArray(_data["projectCountries"])) {
                this.projectCountries = [] as any;
                for (let item of _data["projectCountries"])
                    this.projectCountries!.push(ProjectCountries.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CountryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["initial"] = this.initial;
        if (Array.isArray(this.projectCountries)) {
            data["projectCountries"] = [];
            for (let item of this.projectCountries)
                data["projectCountries"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICountryDTO {
    id?: number;
    name?: string;
    initial?: string;
    projectCountries?: ProjectCountries[];
}

export class CreateProjectCountryCommand implements ICreateProjectCountryCommand {
    projectId?: number;
    countryId?: number;

    constructor(data?: ICreateProjectCountryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): CreateProjectCountryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectCountryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["countryId"] = this.countryId;
        return data;
    }
}

export interface ICreateProjectCountryCommand {
    projectId?: number;
    countryId?: number;
}

export class CreateCountryCommand implements ICreateCountryCommand {
    name?: string | undefined;
    initial?: string | undefined;

    constructor(data?: ICreateCountryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.initial = _data["initial"];
        }
    }

    static fromJS(data: any): CreateCountryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCountryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["initial"] = this.initial;
        return data;
    }
}

export interface ICreateCountryCommand {
    name?: string | undefined;
    initial?: string | undefined;
}

export class CustomerDTO implements ICustomerDTO {
    id?: number;
    name?: string;
    photoUrl?: string;
    verticalId?: number;
    vertical?: Vertical | undefined;
    sectorId?: number;
    sector?: Sector | undefined;
    project?: Project | undefined;

    constructor(data?: ICustomerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.photoUrl = _data["photoUrl"];
            this.verticalId = _data["verticalId"];
            this.vertical = _data["vertical"] ? Vertical.fromJS(_data["vertical"]) : <any>undefined;
            this.sectorId = _data["sectorId"];
            this.sector = _data["sector"] ? Sector.fromJS(_data["sector"]) : <any>undefined;
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["photoUrl"] = this.photoUrl;
        data["verticalId"] = this.verticalId;
        data["vertical"] = this.vertical ? this.vertical.toJSON() : <any>undefined;
        data["sectorId"] = this.sectorId;
        data["sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICustomerDTO {
    id?: number;
    name?: string;
    photoUrl?: string;
    verticalId?: number;
    vertical?: Vertical | undefined;
    sectorId?: number;
    sector?: Sector | undefined;
    project?: Project | undefined;
}

export class CreateCustomerCommand implements ICreateCustomerCommand {
    name?: string | undefined;
    photoUrl?: string | undefined;
    verticalId?: number;
    sectorId?: number;

    constructor(data?: ICreateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.photoUrl = _data["photoUrl"];
            this.verticalId = _data["verticalId"];
            this.sectorId = _data["sectorId"];
        }
    }

    static fromJS(data: any): CreateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["photoUrl"] = this.photoUrl;
        data["verticalId"] = this.verticalId;
        data["sectorId"] = this.sectorId;
        return data;
    }
}

export interface ICreateCustomerCommand {
    name?: string | undefined;
    photoUrl?: string | undefined;
    verticalId?: number;
    sectorId?: number;
}

export class UpdateCustomerCommand implements IUpdateCustomerCommand {
    id?: number;
    name?: string | undefined;
    photoUrl?: string | undefined;
    verticalId?: number;
    sectorId?: number;

    constructor(data?: IUpdateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.photoUrl = _data["photoUrl"];
            this.verticalId = _data["verticalId"];
            this.sectorId = _data["sectorId"];
        }
    }

    static fromJS(data: any): UpdateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["photoUrl"] = this.photoUrl;
        data["verticalId"] = this.verticalId;
        data["sectorId"] = this.sectorId;
        return data;
    }
}

export interface IUpdateCustomerCommand {
    id?: number;
    name?: string | undefined;
    photoUrl?: string | undefined;
    verticalId?: number;
    sectorId?: number;
}

export class PaginatedListOfProjectDTO implements IPaginatedListOfProjectDTO {
    items?: ProjectDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProjectDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProjectDTO.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProjectDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProjectDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProjectDTO {
    items?: ProjectDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProjectDTO implements IProjectDTO {
    id?: number;
    name?: string;
    endYear?: number;
    isFinished?: boolean;
    price?: number;
    manDay?: number;
    solutions?: string | undefined;
    issues?: string | undefined;
    benefits?: string | undefined;
    narative?: string | undefined;
    isPublic?: boolean;
    photoUrl?: string | undefined;
    dataQualityPercent?: number;
    customerId?: number;
    customer?: Customer | undefined;
    projectTribeOffers?: ProjectTribeOffers[];
    projectTags?: ProjectTags[];
    projectCountries?: ProjectCountries[];
    projectTargetsWork?: ProjectTargetsWork[];
    projectContacts?: ProjectContacts[];
    agreements?: Agreement[];
    projectTechnologies?: ProjectTechnologies[];
    projectChannels?: ProjectChannels[];

    constructor(data?: IProjectDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.endYear = _data["endYear"];
            this.isFinished = _data["isFinished"];
            this.price = _data["price"];
            this.manDay = _data["manDay"];
            this.solutions = _data["solutions"];
            this.issues = _data["issues"];
            this.benefits = _data["benefits"];
            this.narative = _data["narative"];
            this.isPublic = _data["isPublic"];
            this.photoUrl = _data["photoUrl"];
            this.dataQualityPercent = _data["dataQualityPercent"];
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            if (Array.isArray(_data["projectTribeOffers"])) {
                this.projectTribeOffers = [] as any;
                for (let item of _data["projectTribeOffers"])
                    this.projectTribeOffers!.push(ProjectTribeOffers.fromJS(item));
            }
            if (Array.isArray(_data["projectTags"])) {
                this.projectTags = [] as any;
                for (let item of _data["projectTags"])
                    this.projectTags!.push(ProjectTags.fromJS(item));
            }
            if (Array.isArray(_data["projectCountries"])) {
                this.projectCountries = [] as any;
                for (let item of _data["projectCountries"])
                    this.projectCountries!.push(ProjectCountries.fromJS(item));
            }
            if (Array.isArray(_data["projectTargetsWork"])) {
                this.projectTargetsWork = [] as any;
                for (let item of _data["projectTargetsWork"])
                    this.projectTargetsWork!.push(ProjectTargetsWork.fromJS(item));
            }
            if (Array.isArray(_data["projectContacts"])) {
                this.projectContacts = [] as any;
                for (let item of _data["projectContacts"])
                    this.projectContacts!.push(ProjectContacts.fromJS(item));
            }
            if (Array.isArray(_data["agreements"])) {
                this.agreements = [] as any;
                for (let item of _data["agreements"])
                    this.agreements!.push(Agreement.fromJS(item));
            }
            if (Array.isArray(_data["projectTechnologies"])) {
                this.projectTechnologies = [] as any;
                for (let item of _data["projectTechnologies"])
                    this.projectTechnologies!.push(ProjectTechnologies.fromJS(item));
            }
            if (Array.isArray(_data["projectChannels"])) {
                this.projectChannels = [] as any;
                for (let item of _data["projectChannels"])
                    this.projectChannels!.push(ProjectChannels.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["endYear"] = this.endYear;
        data["isFinished"] = this.isFinished;
        data["price"] = this.price;
        data["manDay"] = this.manDay;
        data["solutions"] = this.solutions;
        data["issues"] = this.issues;
        data["benefits"] = this.benefits;
        data["narative"] = this.narative;
        data["isPublic"] = this.isPublic;
        data["photoUrl"] = this.photoUrl;
        data["dataQualityPercent"] = this.dataQualityPercent;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (Array.isArray(this.projectTribeOffers)) {
            data["projectTribeOffers"] = [];
            for (let item of this.projectTribeOffers)
                data["projectTribeOffers"].push(item.toJSON());
        }
        if (Array.isArray(this.projectTags)) {
            data["projectTags"] = [];
            for (let item of this.projectTags)
                data["projectTags"].push(item.toJSON());
        }
        if (Array.isArray(this.projectCountries)) {
            data["projectCountries"] = [];
            for (let item of this.projectCountries)
                data["projectCountries"].push(item.toJSON());
        }
        if (Array.isArray(this.projectTargetsWork)) {
            data["projectTargetsWork"] = [];
            for (let item of this.projectTargetsWork)
                data["projectTargetsWork"].push(item.toJSON());
        }
        if (Array.isArray(this.projectContacts)) {
            data["projectContacts"] = [];
            for (let item of this.projectContacts)
                data["projectContacts"].push(item.toJSON());
        }
        if (Array.isArray(this.agreements)) {
            data["agreements"] = [];
            for (let item of this.agreements)
                data["agreements"].push(item.toJSON());
        }
        if (Array.isArray(this.projectTechnologies)) {
            data["projectTechnologies"] = [];
            for (let item of this.projectTechnologies)
                data["projectTechnologies"].push(item.toJSON());
        }
        if (Array.isArray(this.projectChannels)) {
            data["projectChannels"] = [];
            for (let item of this.projectChannels)
                data["projectChannels"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProjectDTO {
    id?: number;
    name?: string;
    endYear?: number;
    isFinished?: boolean;
    price?: number;
    manDay?: number;
    solutions?: string | undefined;
    issues?: string | undefined;
    benefits?: string | undefined;
    narative?: string | undefined;
    isPublic?: boolean;
    photoUrl?: string | undefined;
    dataQualityPercent?: number;
    customerId?: number;
    customer?: Customer | undefined;
    projectTribeOffers?: ProjectTribeOffers[];
    projectTags?: ProjectTags[];
    projectCountries?: ProjectCountries[];
    projectTargetsWork?: ProjectTargetsWork[];
    projectContacts?: ProjectContacts[];
    agreements?: Agreement[];
    projectTechnologies?: ProjectTechnologies[];
    projectChannels?: ProjectChannels[];
}

export class CreateProjectCommand implements ICreateProjectCommand {
    name?: string | undefined;
    endYear?: number;
    isFinished?: boolean;
    price?: number;
    manDay?: number;
    solutions?: string | undefined;
    issues?: string | undefined;
    benefits?: string | undefined;
    narative?: string | undefined;
    isPublic?: boolean;
    photoUrl?: string | undefined;
    customerId?: number;

    constructor(data?: ICreateProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.endYear = _data["endYear"];
            this.isFinished = _data["isFinished"];
            this.price = _data["price"];
            this.manDay = _data["manDay"];
            this.solutions = _data["solutions"];
            this.issues = _data["issues"];
            this.benefits = _data["benefits"];
            this.narative = _data["narative"];
            this.isPublic = _data["isPublic"];
            this.photoUrl = _data["photoUrl"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): CreateProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["endYear"] = this.endYear;
        data["isFinished"] = this.isFinished;
        data["price"] = this.price;
        data["manDay"] = this.manDay;
        data["solutions"] = this.solutions;
        data["issues"] = this.issues;
        data["benefits"] = this.benefits;
        data["narative"] = this.narative;
        data["isPublic"] = this.isPublic;
        data["photoUrl"] = this.photoUrl;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface ICreateProjectCommand {
    name?: string | undefined;
    endYear?: number;
    isFinished?: boolean;
    price?: number;
    manDay?: number;
    solutions?: string | undefined;
    issues?: string | undefined;
    benefits?: string | undefined;
    narative?: string | undefined;
    isPublic?: boolean;
    photoUrl?: string | undefined;
    customerId?: number;
}

export class UpdateProjectCommand implements IUpdateProjectCommand {
    id?: number;
    name?: string | undefined;
    endYear?: number;
    isFinished?: boolean;
    price?: number;
    manDay?: number;
    solutions?: string | undefined;
    issues?: string | undefined;
    benefits?: string | undefined;
    narative?: string | undefined;
    isPublic?: boolean;
    photoUrl?: string | undefined;
    customerId?: number;

    constructor(data?: IUpdateProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.endYear = _data["endYear"];
            this.isFinished = _data["isFinished"];
            this.price = _data["price"];
            this.manDay = _data["manDay"];
            this.solutions = _data["solutions"];
            this.issues = _data["issues"];
            this.benefits = _data["benefits"];
            this.narative = _data["narative"];
            this.isPublic = _data["isPublic"];
            this.photoUrl = _data["photoUrl"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): UpdateProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["endYear"] = this.endYear;
        data["isFinished"] = this.isFinished;
        data["price"] = this.price;
        data["manDay"] = this.manDay;
        data["solutions"] = this.solutions;
        data["issues"] = this.issues;
        data["benefits"] = this.benefits;
        data["narative"] = this.narative;
        data["isPublic"] = this.isPublic;
        data["photoUrl"] = this.photoUrl;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface IUpdateProjectCommand {
    id?: number;
    name?: string | undefined;
    endYear?: number;
    isFinished?: boolean;
    price?: number;
    manDay?: number;
    solutions?: string | undefined;
    issues?: string | undefined;
    benefits?: string | undefined;
    narative?: string | undefined;
    isPublic?: boolean;
    photoUrl?: string | undefined;
    customerId?: number;
}

export class SectorDTO implements ISectorDTO {
    id?: number;
    name?: string;
    verticalId?: number;
    vertical?: Vertical | undefined;
    customers?: Customer[];

    constructor(data?: ISectorDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.verticalId = _data["verticalId"];
            this.vertical = _data["vertical"] ? Vertical.fromJS(_data["vertical"]) : <any>undefined;
            if (Array.isArray(_data["customers"])) {
                this.customers = [] as any;
                for (let item of _data["customers"])
                    this.customers!.push(Customer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SectorDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SectorDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["verticalId"] = this.verticalId;
        data["vertical"] = this.vertical ? this.vertical.toJSON() : <any>undefined;
        if (Array.isArray(this.customers)) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISectorDTO {
    id?: number;
    name?: string;
    verticalId?: number;
    vertical?: Vertical | undefined;
    customers?: Customer[];
}

export class CreateSectorCommand implements ICreateSectorCommand {
    name?: string | undefined;
    verticalId?: number;

    constructor(data?: ICreateSectorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.verticalId = _data["verticalId"];
        }
    }

    static fromJS(data: any): CreateSectorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSectorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["verticalId"] = this.verticalId;
        return data;
    }
}

export interface ICreateSectorCommand {
    name?: string | undefined;
    verticalId?: number;
}

export class TagDTO implements ITagDTO {
    id?: number;
    name?: string;
    projectTags?: ProjectTags[];

    constructor(data?: ITagDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["projectTags"])) {
                this.projectTags = [] as any;
                for (let item of _data["projectTags"])
                    this.projectTags!.push(ProjectTags.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TagDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TagDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.projectTags)) {
            data["projectTags"] = [];
            for (let item of this.projectTags)
                data["projectTags"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITagDTO {
    id?: number;
    name?: string;
    projectTags?: ProjectTags[];
}

export class CreateProjectTagCommand implements ICreateProjectTagCommand {
    projectId?: number;
    tagId?: number;

    constructor(data?: ICreateProjectTagCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.tagId = _data["tagId"];
        }
    }

    static fromJS(data: any): CreateProjectTagCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectTagCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["tagId"] = this.tagId;
        return data;
    }
}

export interface ICreateProjectTagCommand {
    projectId?: number;
    tagId?: number;
}

export class CreateTagCommand implements ICreateTagCommand {
    name?: string | undefined;

    constructor(data?: ICreateTagCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateTagCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTagCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateTagCommand {
    name?: string | undefined;
}

export class TargetWorkDTO implements ITargetWorkDTO {
    id?: number;
    name?: string;
    projectTargetsWork?: ProjectTargetsWork[];

    constructor(data?: ITargetWorkDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["projectTargetsWork"])) {
                this.projectTargetsWork = [] as any;
                for (let item of _data["projectTargetsWork"])
                    this.projectTargetsWork!.push(ProjectTargetsWork.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TargetWorkDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TargetWorkDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.projectTargetsWork)) {
            data["projectTargetsWork"] = [];
            for (let item of this.projectTargetsWork)
                data["projectTargetsWork"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITargetWorkDTO {
    id?: number;
    name?: string;
    projectTargetsWork?: ProjectTargetsWork[];
}

export class CreateProjectTargetWorkCommand implements ICreateProjectTargetWorkCommand {
    projectId?: number;
    targetWorkId?: number;

    constructor(data?: ICreateProjectTargetWorkCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.targetWorkId = _data["targetWorkId"];
        }
    }

    static fromJS(data: any): CreateProjectTargetWorkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectTargetWorkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["targetWorkId"] = this.targetWorkId;
        return data;
    }
}

export interface ICreateProjectTargetWorkCommand {
    projectId?: number;
    targetWorkId?: number;
}

export class CreateTargetWorkCommand implements ICreateTargetWorkCommand {
    name?: string | undefined;

    constructor(data?: ICreateTargetWorkCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateTargetWorkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTargetWorkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateTargetWorkCommand {
    name?: string | undefined;
}

export class TechnologyDTO implements ITechnologyDTO {
    id?: number;
    name?: string;
    projectTechnologies?: ProjectTechnologies[];

    constructor(data?: ITechnologyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["projectTechnologies"])) {
                this.projectTechnologies = [] as any;
                for (let item of _data["projectTechnologies"])
                    this.projectTechnologies!.push(ProjectTechnologies.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TechnologyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TechnologyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.projectTechnologies)) {
            data["projectTechnologies"] = [];
            for (let item of this.projectTechnologies)
                data["projectTechnologies"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITechnologyDTO {
    id?: number;
    name?: string;
    projectTechnologies?: ProjectTechnologies[];
}

export class CreateProjectTechnologyCommand implements ICreateProjectTechnologyCommand {
    projectId?: number;
    technologyId?: number;

    constructor(data?: ICreateProjectTechnologyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.technologyId = _data["technologyId"];
        }
    }

    static fromJS(data: any): CreateProjectTechnologyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectTechnologyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["technologyId"] = this.technologyId;
        return data;
    }
}

export interface ICreateProjectTechnologyCommand {
    projectId?: number;
    technologyId?: number;
}

export class CreateTechnologyCommand implements ICreateTechnologyCommand {
    name?: string | undefined;

    constructor(data?: ICreateTechnologyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateTechnologyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTechnologyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateTechnologyCommand {
    name?: string | undefined;
}

export class TribeOfferDTO implements ITribeOfferDTO {
    id?: number;
    name?: string;
    projectTribeOffers?: ProjectTribeOffers[];

    constructor(data?: ITribeOfferDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["projectTribeOffers"])) {
                this.projectTribeOffers = [] as any;
                for (let item of _data["projectTribeOffers"])
                    this.projectTribeOffers!.push(ProjectTribeOffers.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TribeOfferDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TribeOfferDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.projectTribeOffers)) {
            data["projectTribeOffers"] = [];
            for (let item of this.projectTribeOffers)
                data["projectTribeOffers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITribeOfferDTO {
    id?: number;
    name?: string;
    projectTribeOffers?: ProjectTribeOffers[];
}

export class CreateProjectTribeOfferCommand implements ICreateProjectTribeOfferCommand {
    projectId?: number;
    tribeOfferId?: number;

    constructor(data?: ICreateProjectTribeOfferCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.tribeOfferId = _data["tribeOfferId"];
        }
    }

    static fromJS(data: any): CreateProjectTribeOfferCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectTribeOfferCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["tribeOfferId"] = this.tribeOfferId;
        return data;
    }
}

export interface ICreateProjectTribeOfferCommand {
    projectId?: number;
    tribeOfferId?: number;
}

export class CreateTribeOfferCommand implements ICreateTribeOfferCommand {
    name?: string | undefined;

    constructor(data?: ICreateTribeOfferCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateTribeOfferCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTribeOfferCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateTribeOfferCommand {
    name?: string | undefined;
}

export class VerticalDTO implements IVerticalDTO {
    id?: number;
    name?: string;
    sectors?: Sector[];
    customers?: Customer[];

    constructor(data?: IVerticalDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["sectors"])) {
                this.sectors = [] as any;
                for (let item of _data["sectors"])
                    this.sectors!.push(Sector.fromJS(item));
            }
            if (Array.isArray(_data["customers"])) {
                this.customers = [] as any;
                for (let item of _data["customers"])
                    this.customers!.push(Customer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VerticalDTO {
        data = typeof data === 'object' ? data : {};
        let result = new VerticalDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.sectors)) {
            data["sectors"] = [];
            for (let item of this.sectors)
                data["sectors"].push(item.toJSON());
        }
        if (Array.isArray(this.customers)) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVerticalDTO {
    id?: number;
    name?: string;
    sectors?: Sector[];
    customers?: Customer[];
}

export class CreateVerticalCommand implements ICreateVerticalCommand {
    name?: string | undefined;

    constructor(data?: ICreateVerticalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateVerticalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVerticalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateVerticalCommand {
    name?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}